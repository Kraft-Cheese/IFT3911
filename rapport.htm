<html>
<head>
    <title>IFT3911 DM1</title>
    <style type="text/css">
        table
        {
            border: outset 2px black;
            border-collapse: collapse;
        }
        th
        {
            border-bottom: double 2px black;
        }
        td
        {
            border-bottom: solid 1px black;
        }
        .first_col
        {
            border-right: double 2px black;
        }
    </style>
</head>
<body>
    <h1 style="text-align: center;">
        IFT 3911 - Devoir 2 - Mike</h1>
    <h2>
        Information générale</h2>
    <p>
        <span style="font-weight: bold;">Nom: </span>Amélie Coughlan
        <br />
        <span style="font-weight: bold;">Matricule: </span> 9813
        <br />
        <span style="font-weight: bold;">Courriel: </span>amelie.therese.coughlan@umontreal.ca
        <br />
        <span style="font-weight: bold;">temps mis: </span> 20h
    </p>
    <p>
        <span style="font-weight: bold;">Nom: </span>Cassandre Hamel
        <br />
        <span style="font-weight: bold;">Matricule: </span> 0863
        <br />
        <span style="font-weight: bold;">Courriel: </span>cassandre.hamel.1@umontreal.ca
        <br />
        <span style="font-weight: bold;">temps mis: </span> 20h
    </p>
    <p>
        <span style="font-weight: bold;">Nom: </span>Alessandra Mancas
        <br />
        <span style="font-weight: bold;">Matricule: </span>9098
        <br />
        <span style="font-weight: bold;">Courriel: </span>alessandra.thais.mancas@umontreal.ca
        <br />
        <span style="font-weight: bold;">temps mis: </span> 20h
    </p>
    <h2>
        Distribution des tâches</h2>
    <p>
        <span style="font-weight: bold;">Soumetteur: </span>Alessandra Mancas
    </p>
    <table cellpadding="7px">
        <thead>
            <tr>
                <th>
                    Amélie
                </th>
                <th>
                    Cassandre
                </th>
                <th>
                    Alessandra
                </th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>
                    Statechart, OCL, qualité du design, rapport
                </td>
                <td>
                    Réseau de Pétri, diagramme de paquets, diagramme de classes, qualité du design, rapport
                </td>
                <td>
                    Diagramme de classes, diagrammes de séquence, OCL, qualité du design, rapport
                </td>
            </tr>

        </tbody>
    </table>

    <h2>Tâche 1 - Réseau de Pétri: Tunnel</h2>

    <h3>Modélisation du réseau de Pétri</h3>
    <p>
        <img src="./Diagrammes/PetriNetTunnel.png" alt="Réseau de Pétri" style="max-width: 100%; height: auto; display: block; margin-top: 10px;">
    </p>

    <h3>Analyse du réseau de Pétri</h3>
    <h4>Places: </h4>
    <p>
        <ul>
            <li>P_m, P_rs: représente la présence d'une voiture en attente soit à l'entrée du tunnel (Montreal) ou à l'entrée du tunnel (Rive-Sud).</li>
            <li>G_m, G_rs: représente si le feu est vert à l'entrée du tunnel (Montreal) ou à l'entrée du tunnel (Rive-Sud).</li>
            <li>D_m, D_rs: représente vers où la voiture va, soit Montreal ou Rive-Sud.</li>
            <li>T_m->rs, T_rs->m: représente le tunnel, soit de Montreal à Rive-Sud ou de Rive-Sud à Montreal.</li>
        </ul>
        <p>
            P_m et P_rs ont toujours une voiture en attente ainsi elles ont toujours un jeton.
        </p>
    <h4>Transitions: </h4>
    <p>
       <ul>
        <li>t_m_en, t_rs_en: représente l'entrée d'une voiture à l'entrée du tunnel (Montreal) ou à l'entrée du tunnel (Rive-Sud).</li>
        <li>t_ex_m, t_ex_rs: représente la sortie d'une voiture à l'entrée du tunnel (Montreal) ou à l'entrée du tunnel (Rive-Sud).</li>
       </ul>
    </p>
    <h4>Les arcs: </h4>
    <!--Should be tables : Transition | Places in | Places out -->

    <table cellpadding="7px">
        <thead>
            <tr>
                <th>
                    Transition
                </th>
                <th>
                    Places entrantes
                </th>
                <th>
                    Places sortantes
                </th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>
                    t_m_en
                </td>
                <td>
                    P_m, G_m, D_rs
                </td>
                <td>
                    P_m, T_m->rs
                </td>
            </tr>
            <tr>
                <td>
                    t_rs_en
                </td>
                <td>
                    P_rs, G_rs, D_m
                </td>
                <td>
                    P_rs, T_rs->m
                </td>
            </tr>
            <tr>
                <td>
                    t_ex_m
                </td>
                <td>
                    T_rs->m
                </td>
                <td>
                    D_rs, G_m
                </td>
            </tr>
            <tr>
                <td>
                    t_ex_rs
                </td>
                <td>
                    T_m->rs
                </td>
                <td>
                    D_m, G_rs
                </td>
            </tr>
        </tbody>

    </table>

    <h4>Marquage initial: </h4>
    <p>
        <ul>
            <li>P_m = 1, P_rs = 1, G_m = 1, G_rs = 0, D_m = 0, D_rs = 1, T_m->rs = 0, T_rs->m = 0</li>
        </ul>
    </p>

    <h4>Loi de conservation: </h4>
    <p>
        Loi 1 - Seulement une voiture dans le tunnel : M(T_m->rs) + M(T_rs->m) + M(G_m) + M(G_rs)  = 1 <br>
            ce qui implique que les voitures ne peuvent pas se croiser : M(T_m->rs) + M(T_rs->m) = 1
            et que les voitures ne peuvent pas entrer dans le tunnel si le feu est rouge : M(G_m) = 0 et M(G_rs) = 0
        Loi 2 - Les voitures alternent entre les deux directions : M(D_m) + M(D_rs) = 1 <br>
            ceci force les voitures à sortir du tunnel dans la direction opposée à celle d'entrée
            et cause une alternance stricte entre les voitures entrant à Montreal et à Rive-Sud
        Loi 3 - Il y a toujours une voiture à chaque entrée : M(P_m) + M(P_rs) = 2 <br>
    </p>

    <h4>Graphe d'accessibilité: </h4>
    <p>
        <ul>
            Pour le noeud : (P_m, G_m, D_rs, T_m->rs, T_rs->m, P_rs, G_rs, D_m) <br>
            <li>1. (1,1,1,0,0,1,0,0) -> t_m_en -> (1,0,0,1,0,1,0,0)</li>
            <li>2. (1,0,0,1,0,1,0,0) -> t_ex_rs -> (1,0,0,0,0,1,1,1)</li>
            <li>3. (1,0,0,0,0,1,1,1) -> t_rs_en -> (1,0,0,0,1,1,0,0)</li>
            <li>4. (1,0,0,0,1,1,0,0) -> t_ex_m -> (1,1,1,0,0,1,0,0)</li>
            <li>5. Le marquage initial est atteint</li>
        </ul>
    </p>

    <h4>Propriétés: </h4>
    <p>Est-ce que le réseau est borné? Oui, car seulement une voiture peut être dans le tunnel à la fois, et il y a toujours une voiture à chaque entrée. </p>
    <p>Y-a-t-il une loi de conservation? Oui, les voitures ne peuvent pas se croiser et les voitures alternent entre les deux directions.</p>
    <p>Y-a-t-il une situation d'interblocage? Non, il y a un cycle qui accede à chaque transition, aucun neoud du graphe reste terminal.</p>
    <p>Y-a-t-il une situation de famine? Non, puisqu'il y a une alternance stricte entre les voitures entrant à Montreal et à Rive-Sud.</p>
    <p>Y-a-t-il des transitions mortes? Non, puisque chaque transition reste activable indefiniment du a l'alternance stricte qui visite chaque transition. (L4) </p>

    </p>



    <h2>Tâche 2 - Statechart: Four à micro-onde</h2>

    <h3>Modélisation du Statechart</h3>

    <p>
        <b>Chemin vers le répertoire du State Chart = ./Statechart/model/microwave.sct</b>
        <p>
            <img src="./Diagrammes/StateChart.png" alt="Statechart" style="max-width: 100%; height: auto; display: block; margin-top: 10px;">
        </p>
    </p>
    <h3>Précisions</h3>
        <p>
            <ul>
                <li>
                    <i>La porte peut être ouverte ou fermée en tout temps. Pour des raisons de sécurité, la cuisson ne peut avoir lieu si la porte est ouverte. Durant la cuisson, l'ouverture de la porte interrompt la cuisson. Le message 'Waiting' est alors affiché. Lorsque la porte est refermée, l'afficheur affiche le texte précédent l'ouverture (message ou temps).</i>
                    <br><br>
                    Il y a ici une ambiguïté dans les instructions quant à si on doit afficher le 'Waiting' seulement quand on ouvre la porte pendant la cuisson, ou si on doit l'afficher n'importe quand qu'on l'ouvre. Après plusieurs interactions avec plusieurs micro-ondes différents, nous avons conclu qu'il est possible de faire d'autres inputs dans le clavier du micro-ondes pendant qu'il est ouvert, sauf pour partir la cuisson. Dans ce cas, il ne ferait pas de sens d'afficher 'Waiting', étant donné qu'on doit continuer à afficher le résultat des inputs. Nous avons décidé d'implémenter ce comportement. Donc, ce message est seulement affiché quand on ouvre la porte pendant la cuisson. Aucun input ne peut être entré pendant ce temps, on peut seulement fermer la porte, ou appuyer sur stop pour recommencer le processus.
                </li>
                <br>
                <li>
                    <i>Appuyer sur stop arrête tout le processus et met le système au repos.</i>
                    <br><br>
                    Nous avons interprété le fait de mettre le système au repos de le recommencer. Donc, quand on appuie sur stop à n'importe quel moment, que ce soit pendant la cuisson ou pendant de l'input dans le clavier, on interromp tout et on peut recommencer.
                </li>
                <br>
                <li>
                    Pour une raison quelconque, les triggers 'always' et 'oncycle' ne marchaient pas tout à fait de la manière attendue. La documentation de Yakindu indique clairement que les transitions avec un de ces triggers se déclenchera immédiatement lorsque les fonctions entry/ et exit/ ont terminé dans l'état de départ. Toutefois, il fallait toujours peser sur n'importe quel bouton sur le clavier pour permettre la transition. C'est pourquoi il y a 2 transitions qui ont comme trigger <b>after 2ms</b>, c'était la meilleure façon de simuler des transitions immédiates (utiliser 0s générait d'autres bogues).
                </li>
            </ul>
        </p>

    <h2>Tâche 3 - Design logiciel</h2>
    <h3>Révision du diagramme de classe</h3>
        <p>
            <!--METTRE IMAGE ET FILE PATH-->

        </p>
    <h3>Révision des diagrammes de séquence</h3>
        <p></p>
    <h3>Révision du diagramme de paquets</h3>
        <p></p>
    <h3>Révision des contraintes OCL</h3>
    <div>
        <p>
            Nous avons vérifié toutes les contraintes OCL qui n'avaient pas d'erreur après la correction du devoir 1, et elles étaient toujours valides pour le nouveau diagramme de classes. Donc, ci-dessous, nous corrigeons uniquement celles qui étaient erronées.
        </p>
        <p>
            <ol>
                <li>
                    <i>Un vol est identifié par un ID qui commence par deux lettres suivi d'une série de chiffres. La partie alphabétique de l'ID d'un vol est unique à chaque compagnie et la partie numérique est unique à chaque vol au sein de la même compagnie.</i>
                    <br><br>
                    context Cie_aerienne <br>
                    &nbsp;&nbsp;&nbsp;&nbsp; inv : self.shortId.size() = 2 <br>
                    &nbsp;&nbsp;&nbsp;&nbsp; inv : self.allInstances() &rarr; isUnique(shortId) <br>
                    &nbsp;&nbsp;&nbsp;&nbsp; inv : self.volsOfferts &rarr; forAll(v1, v2 | v1 <> v2 implies v1.ID.substring(2, v1.ID.size()) <> v2.ID.substring(2, v2.ID.size())) <br>
                    &nbsp;&nbsp;&nbsp;&nbsp; inv : self.volsOfferts &rarr; forAll(v | v.ID.substring(0,2) = self.shortId) <br>
                </li>
                <br>
                <li>
                    <i>Un paquebot peut être assigné à plusieurs itinéraires tant qu'ils ne se chevauchent pas.</i>
                    <br><br>
                    context Paquebot <br>
                    &nbsp;&nbsp;&nbsp;&nbsp; inv : self.total_parcours &rarr; forAll(p1, p2 | p1 <> p2 implies p1 &rarr; intersection(p2) &rarr; isEmpty()) <br>
                    &nbsp;&nbsp;&nbsp;&nbsp; inv : self.total_parcours &rarr; forAll(p1, p2 | p1 <> p2 implies (p1.Date_depart < p1.Date_arrivee && p1.Date_arrivee < p2.Date_depart && p2.Date_depart < p2.Date_arrivee) || (p2.Date_depart < p2.Date_arrivee && p2.Date_arrivee < p1.Date_depart && p1.Date_depart < p1.Date_arrivee)) <br>
                </li>
                <br>
                <li>
                    <i>Le client peut réserver un siège disponible dans un vol (trajet) donné. / Le client peut réserver une cabine disponible pour un itinéraire donné.</i>
                    <br><br>
                    context Systeme::creerReservation(Parcours pa, Section s, Preference pr) <br>
                    &nbsp;&nbsp;&nbsp;&nbsp; pre : s.DispoSect <br>
                    <br>
                    L'erreur qu'on nous a donné ici était que nous avions vérifié la disponiblité de la section et non du siège. Par contre, nous avons fait exprès. Étant donné que les instructions expliquaient que le client <i>a l'option de choisir une priorité entre l'aile ou la fenêtre</i>, nous avons interprété ceci comme de quoi le client ne choisit pas vraiment son siège spécifiquement. Il choisit simplement une section où il aimerait être, une préférence entre l'aile ou la fenêtre, et le système lui assigne un siège spécifique qui remplit (le plus possible) ces critères.
                </li>
                <br>
                <li>
                    <i>Un siège réservé devient assigné à un passager une fois payé: le siège est donc confirmé.</i>
                    <br><br>
                    context Reservation::setValid() <br>
                    &nbsp;&nbsp;&nbsp;&nbsp; post : custController.chargerCarte() = true implies not self.place.DispoPlace <br>
                </li>
                <br>
            </ol>
        </p>
    </div>
    <h3>Identification des modules réutilisables</h3>
        <p></p>

    <h2>Tâche 4 - Qualité du design</h2>
        <p></p>
    <h3>Discussion du couplage et de la cohésion des modules</h3>
        <p></p>
    <h3>Discussion du fardeau des classes</h3>
        <p></p>
    <h3>Graphe IA et justification</h3>
    <img src="./Diagrammes/GrapheIA.jpg" alt="Graphe IA" style="max-width: 100%; height: auto; display: block; margin-top: 10px;">
    <p>
        Le graphe IA montre que nos trois paquets respectent globalement les bonnes pratiques de conception. Le paquet <strong>Interface</strong> est totalement instable (I = 1) et totalement concret (A = 0), ce qui est acceptable, car aucun autre paquet n’en dépend. Il se trouve ainsi sur la diagonale principale du graphe, ce qui respecte le <strong>Stable Abstractions Principle (SAP)</strong>. <br><br>
        Le paquet <strong>Transports</strong> est également bien positionné : il est instable (I = 0.8) et peu abstrait (A = 0.2), ce qui convient à un paquet de modèle d'affaires contenant surtout des entités concrètes. Il se trouve exactement sur la diagonale principale du graphe IA, ce qui montre un bon équilibre entre abstraction et instabilité. <br><br>
        Le seul paquet légèrement problématique est <strong>Core</strong>, qui est relativement stable (I ≈ 0.64) mais pas assez abstrait (A = 0.2). Cela signifie que ce paquet, bien que central, pourrait gagner en flexibilité et en maintenabilité en introduisant davantage d’interfaces ou de classes abstraites pour respecter pleinement le <strong>SAP</strong>. Malgré tout, son écart à la diagonale est modéré comme montré par le graphe IA.
    </p>
    <h3>Justification de l'application des principes de conception</h3>
        <p>
            Nous avons structuré notre système selon une architecture inspirée du modèle MVC afin de bien séparer les responsabilités. Cette séparation respecte plusieurs principes de conception orientée objet :
        <ul>
            <li><strong>SRP</strong> : Chaque paquet a une responsabilité claire, la vue pour <em>Interface</em>, le traitement logique pour <em>Core</em>, et les données d'affaires pour <em>Transports</em>.</li>
            <li><strong>SDP</strong> : Les paquets instables (<em>Interface</em> et <em>Transports</em>) dépendent de <em>Core</em>, qui est plus stable. Il y a toutefois un léger écart à ce principe car <em>Transports</em> dépend d’un paquet qui est plus stable (bien) mais peu abstrait (moins bien).</li>
            <li><strong>SAP</strong> : Les paquets <em>Interface</em> et <em>Transports</em> respectent bien ce principe car leur niveau d’abstraction est proportionnel à leur instabilité. Le paquet <em>Core</em> est stable mais manque un peu d’abstraction.</li>
            <li><strong>ACP</strong> : Notre diagramme de paquets est globalement acyclique. Les dépendances sont orientées vers <em>Core</em>, et aucun paquet ne dépend de <em>Interface</em> (un paquet instable), ce qui évite les cycles.</li>
        </ul>
        </p>

    <h3>Diagramme de paquets</h3>
    <p>
        Nous avons choisi de suivre quelque chose similaire à la structure MVC pour notre diagramme de classe. Ainsi, pour le diagramme de paquets nous avons souhaiter  faire similairement. Le premier paquet "Core" représente le controlleur, le paquet "Interface" représente
        la vue et le paquet "Transport" représente le modèle. Dans "Interface", nous avons inclut les vues des clients et des administrateures avec deux classes concretes.
        Dans "Transports", nous avons inclus les classes qui représentent les entités du domaine, soit les compagnies, les parcours, les moyens de transport et les places (sièges et cabines).
        Dans "Core", nous avons inclus les classes qui représentent les actions que le système peut effectuer, soit les réservations et les paiements, ainsi qu'une communication avec
        l'interface via la classe "System" et l'entité de "Passager", qui existe seulement dans le contexte d'une réservation. Le paquet "Interface" est totalement instable, mais puisque il est totalement concret et aucun autre paquet ne dépend de lui, il n'y a pas de problème.
        Le paquet "Core" est instable, mais il est stable par rapport à "Interface" et "Transport", donc c'est acceptable.
        Le paquet "Transport" est unstable, mais il dépend de "Core" qui est plus stable, de plus il est generallement concret.
        Le diagramme de paquets est aussi generallement acyclic avec seulement des dependances sur core et non les autres paquets qui sont moins stables.
    </p>
    <p>
        <b>Chemin vers le fichier .vpp ./diagrammes/vpp_files/Design/Package/PackageDiagram3911.vpp</b>
        <svg width="1000px" height="400px" style="max-width: 100%; height: auto; display: block; margin-top: 10px;">
            <image href="./Diagrammes/Diag_Pack.png" width="100%" height="100%"  />
        </svg>
    </p>

</body>
</html>
