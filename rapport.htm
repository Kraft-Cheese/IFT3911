<html>
<head>
    <title>IFT3911 DM1</title>
    <style type="text/css">
        table
        {
            border: outset 2px black;
            border-collapse: collapse;
        }
        th
        {
            border-bottom: double 2px black;
        }
        td
        {
            border-bottom: solid 1px black;
        }
        .first_col
        {
            border-right: double 2px black;
        }
    </style>
</head>
<body>
    <h1 style="text-align: center;">
        IFT 3911 - Devoir 1 - Mike</h1>
    <h2>
        Information générale</h2>
    <p>
        <span style="font-weight: bold;">Nom: </span>Amélie Coughlan
        <br />
        <span style="font-weight: bold;">Matricule: </span> 9813
        <br />
        <span style="font-weight: bold;">Courriel: </span>amelie.therese.coughlan@umontreal.ca
        <br />
        <span style="font-weight: bold;">temps mis: </span> 20h
    </p>
    <p>
        <span style="font-weight: bold;">Nom: </span>Cassandre Hamel
        <br />
        <span style="font-weight: bold;">Matricule: </span> 0863
        <br />
        <span style="font-weight: bold;">Courriel: </span>cassandre.hamel.1@umontreal.ca
        <br />
        <span style="font-weight: bold;">temps mis: </span> 20h
    </p>
    <p>
        <span style="font-weight: bold;">Nom: </span>Alessandra Mancas
        <br />
        <span style="font-weight: bold;">Matricule: </span>9098
        <br />
        <span style="font-weight: bold;">Courriel: </span>alessandra.thais.mancas@umontreal.ca
        <br />
        <span style="font-weight: bold;">temps mis: </span> 20h
    </p>
    <h2>
        Distribution des tâches</h2>
    <p>
        <span style="font-weight: bold;">Soumetteur: </span>Alessandra Mancas
    </p>
    <table cellpadding="7px">
        <thead>
            <tr>
                <th>
                    Amélie
                </th>
                <th>
                    Cassandre
                </th>
                <th>
                    Alessandra
                </th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>
                    Modèle du domaine, DSS + séquence (réservation billets), OCL, diagramme de classes
                </td>
                <td>
                    Réseau de Pétri, diagramme paquets, diagramme de classes
                </td>
                <td>
                    Modèle du domaine, DSS + séquence (recherche billets), diagramme de classes, rapport
                </td>
            </tr>

        </tbody>
    </table>

    <h2>Tâche 1 - Réseau de Pétri: Tunnel</h2>

    <h3>Modélisation du réseau de Pétri</h3>
    <p>
        <img src="./Diagrammes/PetriNetTunnel.png" alt="Réseau de Pétri" style="max-width: 100%; height: auto; display: block; margin-top: 10px;">
    </p>

    <h3>Analyse du réseau de Pétri</h3>
    <h4>Places: </h4>
    <p>
        <ul>
            <li>P_m, P_rs: représente la présence d'une voiture en attente soit à l'entrée du tunnel (Montreal) ou à l'entrée du tunnel (Rive-Sud).</li>
            <li>G_m, G_rs: représente si le feu est vert à l'entrée du tunnel (Montreal) ou à l'entrée du tunnel (Rive-Sud).</li>
            <li>D_m, D_rs: représente vers où la voiture va, soit Montreal ou Rive-Sud.</li>
            <li>T_m->rs, T_rs->m: représente le tunnel, soit de Montreal à Rive-Sud ou de Rive-Sud à Montreal.</li>
        </ul>
        <p>
            P_m et P_rs ont toujours une voiture en attente ainsi elles ont toujours un jeton.
        </p>
    <h4>Transitions: </h4>
    <p>
       <ul>
        <li>t_m_en, t_rs_en: représente l'entrée d'une voiture à l'entrée du tunnel (Montreal) ou à l'entrée du tunnel (Rive-Sud).</li>
        <li>t_ex_m, t_ex_rs: représente la sortie d'une voiture à l'entrée du tunnel (Montreal) ou à l'entrée du tunnel (Rive-Sud).</li>
       </ul>
    </p>
    <h4>Les arcs: </h4>
    <!--Should be tables : Transition | Places in | Places out -->

    <table cellpadding="7px">
        <thead>
            <tr>
                <th>
                    Transition
                </th>
                <th>
                    Places entrantes
                </th>
                <th>
                    Places sortantes
                </th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>
                    t_m_en
                </td>
                <td>
                    P_m, G_m, D_rs
                </td>
                <td>
                    P_m, T_m->rs
                </td>
            </tr>
            <tr>
                <td>
                    t_rs_en
                </td>
                <td>
                    P_rs, G_rs, D_m
                </td>
                <td>
                    P_rs, T_rs->m
                </td>
            </tr>
            <tr>
                <td>
                    t_ex_m
                </td>
                <td>
                    T_rs->m
                </td>
                <td>
                    D_rs, G_m
                </td>
            </tr>
            <tr>
                <td>
                    t_ex_rs
                </td>
                <td>
                    T_m->rs
                </td>
                <td>
                    D_m, G_rs
                </td>
            </tr>
        </tbody>

    </table>

    <h4>Marquage initial: </h4>
    <p>
        <ul>
            <li>P_m = 1, P_rs = 1, G_m = 1, G_rs = 0, D_m = 0, D_rs = 1, T_m->rs = 0, T_rs->m = 0</li>
        </ul>
    </p>

    <h4>Loi de conservation: </h4>
    <p>
        Loi 1 - Seulement une voiture dans le tunnel : M(T_m->rs) + M(T_rs->m) + M(G_m) + M(G_rs)  = 1 <br>
            ce qui implique que les voitures ne peuvent pas se croiser : M(T_m->rs) + M(T_rs->m) = 1
            et que les voitures ne peuvent pas entrer dans le tunnel si le feu est rouge : M(G_m) = 0 et M(G_rs) = 0
        Loi 2 - Les voitures alternent entre les deux directions : M(D_m) + M(D_rs) = 1 <br>
            ceci force les voitures à sortir du tunnel dans la direction opposée à celle d'entrée
            et cause une alternance stricte entre les voitures entrant à Montreal et à Rive-Sud
        Loi 3 - Il y a toujours une voiture à chaque entrée : M(P_m) + M(P_rs) = 2 <br>
    </p>

    <h4>Graphe d'accessibilité: </h4>
    <p>
        <ul>
            Pour le noeud : (P_m, G_m, D_rs, T_m->rs, T_rs->m, P_rs, G_rs, D_m) <br>
            <li>1. (1,1,1,0,0,1,0,0) -> t_m_en -> (1,0,0,1,0,1,0,0)</li>
            <li>2. (1,0,0,1,0,1,0,0) -> t_ex_rs -> (1,0,0,0,0,1,1,1)</li>
            <li>3. (1,0,0,0,0,1,1,1) -> t_rs_en -> (1,0,0,0,1,1,0,0)</li>
            <li>4. (1,0,0,0,1,1,0,0) -> t_ex_m -> (1,1,1,0,0,1,0,0)</li>
            <li>5. Le marquage initial est atteint</li>
        </ul>
    </p>

    <h4>Propriétés: </h4>
    <p>Est-ce que le réseau est borné? Oui, car seulement une voiture peut être dans le tunnel à la fois, et il y a toujours une voiture à chaque entrée. </p>
    <p>Y-a-t-il une loi de conservation? Oui, les voitures ne peuvent pas se croiser et les voitures alternent entre les deux directions.</p>
    <p>Y-a-t-il une situation d'interblocage? Non, il y a un cycle qui accede à chaque transition, aucun neoud du graphe reste terminal.</p>
    <p>Y-a-t-il une situation de famine? Non, puisqu'il y a une alternance stricte entre les voitures entrant à Montreal et à Rive-Sud.</p>
    <p>Y-a-t-il des transitions mortes? Non, puisque chaque transition reste activable indefiniment du a l'alternance stricte qui visite chaque transition. (L4) </p>

    </p>



    <h2>Tâche 2 - Statechart: Four à micro-onde</h2>

    <h3>Modélisation du Statechart</h3>

    <p>
        <b>Chemin vers le répertoire du State Chart = ./Microwave</b>
        <p>
            <img src="./Diagrammes/StateChart.png" alt="Réseau de Pétri" style="max-width: 100%; height: auto; display: block; margin-top: 10px;">
        </p>
    </p>
    <h3>Précisions</h3>
        <p>
            <ul>
                <li>
                    <i>La porte peut être ouverte ou fermée en tout temps. Pour des raisons de sécurité, la cuisson ne peut avoir lieu si la porte est ouverte. Durant la cuisson, l'ouverture de la porte interrompt la cuisson. Le message 'Waiting' est alors affiché. Lorsque la porte est refermée, l'afficheur affiche le texte précédent l'ouverture (message ou temps).</i>
                    <br><br>
                    Il y a ici une ambiguïté dans les instructions quant à si on doit afficher le 'Waiting' seulement quand on ouvre la porte pendant la cuisson, ou si on doit l'afficher n'importe quand qu'on l'ouvre. Après plusieurs interactions avec plusieurs micro-ondes différents, nous avons conclu qu'il est possible de faire d'autres inputs dans le clavier du micro-ondes pendant qu'il est ouvert, sauf pour partir la cuisson. Dans ce cas, il ne ferait pas de sens d'afficher 'Waiting', étant donné qu'on doit continuer à afficher le résultat des inputs. Nous avons décidé d'implémenter ce comportement. Donc, ce message est seulement affiché quand on ouvre la porte pendant la cuisson. Aucun input ne peut être entré pendant ce temps, on peut seulement fermer la porte, ou appuyer sur stop pour recommencer le processus.
                </li>
                <br>
                <li>
                    <i>Appuyer sur stop arrête tout le processus et met le système au repos.</i>
                    <br><br>
                    Nous avons interprété le fait de mettre le système au repos de le recommencer. Donc, quand on appuie sur stop à n'importe quel moment, que ce soit pendant la cuisson ou pendant de l'input dans le clavier, on interromp tout et on peut recommencer. 
                </li>
                <br>
                <li>
                    Pour une raison quelconque, les triggers 'always' et 'oncycle' ne marchaient pas tout à fait de la manière intendue. La documentation de Yakindu indique clairement que les transitions avec un de ces triggers se déclenchera immédiatement lorsque les fonctions entry/ et exit/ ont terminé dans l'état de départ. Toutefois, il fallait toujours peser sur n'importe quel bouton sur le clavier pour permettre la transition. C'est pourquoi il y a 2 transitions qui ont comme trigger <b>after 2ms</b>, c'était la meilleure façon de simuler des transitions immédiates (utiliser 0s générait d'autres bogues).
                </li>
            </ul>
        </p>

    <h2>Design logiciel</h2>
    <h3>Révision du diagramme de classe</h3>
        <p></p>
    <h3>Révision des diagrammes de séquence</h3>
        <p></p>
    <h3>Révision du diagramme de paquets</h3>
        <p></p>
    <h3>Révision des contraintes OCL</h3>
        <p></p>
    <h3>Identification des modules réutilisables</h3>
        <p></p>

    <h2>Qualité du design</h2>
        <p></p>
    <h3>Discussion du couplage et de la cohésion des modules</h3>
        <p></p>
    <h3>Discussion du fardeau des classes</h3>
        <p></p>
    <h3>Graphe IA et justification</h3>
        <svg width="1000px" height="400px" style="max-width: 100%; height: auto; display: block; margin-top: 10px;">
            <image href="./diagrammes/IA_graph.png" width="100%" height="100%"  />
        </svg>
        <p></p>
    <h3>Justification de l'application des principes de conception</h3>
        <p></p>

    <h3>Diagramme de classes</h3>
    <p>
        Notre diagramme de classes suit ce qu'on a décidé dans le modèle du domaine, mais avec plus de détails sur les méthodes et les
        attributs. On garde le concept d'héritage pour les classes ModeTransport, Parcours et Hub, puisqu'elles ont beaucoup d'attributs en commun.
        On a ensuite spécialisé cette classe en ajoutant des fonctions propres à chaque moyen de transport ou de trajet, telles que l'option de modifier
        une liste de ports dans un itinéraire, qui lui aussi a une liste de ports. <br>
        On a souvent utilisé la composition pour lier un mode de transport précis, un hub, et un parcours donné. En effet, on ne peut pas avoir de vol
        sans des aéroports, si un aéorport change l'entité "Vol" qui le contient change également puis sans une compagnie aérienne, il n'y a pas de vols.
        Cette logique est la même pour les autres moyens de transport. <br>
        Par la suite, nous avons utilisé plusieurs Enum pour les attributs ayant un ensemble strict d'options (les types de sections,
        les types de sièges, les types de cabines). À noter également que si on fait une réservation pour un Paquebot,
        le système assignera par défaut la valeur "Aucune" à préférence, puisque ce sont des cabines et non des sièges.<br>
        Enfin, nous avons ajouté une classe "Passager" qui n'est pas dans le modèle du domaine, mais qui est nécessaire pour qu'un usager
        (et l'administrateur) garde une trace des réservations et des coordonnées.
    </p>
    <p>
        <b>Chemin vers le fichier .vpp = ./vpp_files/Design/Classes/class_diag.vpp</b>
        <svg width="1500px" height="600px" style="max-width: 100%; height: auto; display: block; margin-top: 10px;">
            <image href="./diagrammes/Class_diag.png" width="100%" height="100%"  />
        </svg>
    </p>

    <!-- <h3>Diagrammes de séquence</h3>

    <h4>Vérifier les vols/lignes/itinéraires</h4>
    <p>
        Nous avons conservé la même logique que le DSS pour ce scénario, Nous avons simplement adapté les méthodes et les classes.
        Le système regarde parmi tous les vols offerts dans la liste all_parcours et vérifie s'il reste des places avec check_available.
        Ensuite, chaque résultat sera mis dans une liste qui sera retournée par resultats_serch via l'affichage de l'interface. <br>
        Encore une fois, ce diagramme s'applique également aux autres modes de transport.
    </p>
    <p>
        <b>Chemin vers le fichier .vpp = ./diagrammes/vpp_files/Design/Sequences/Scenario_1.vpp</b>
        <svg width="1000px" height="400px" style="max-width: 100%; height: auto; display: block; margin-top: 10px;">
            <image href="./diagrammes/Sequence_research.png" width="100%" height="100%"  />
        </svg>
    </p>

    <h4>Réserver un siège</h4>
    <p>
        On se trouve dans la même situation que dans le DSS, mais on a adapté les méthodes et les classes.
        Lorsqu'il y a un succès, on instancie une Réservation avec le parcours choisi, la section et siège et le moyen de transport.
        Les informations du client seront ajoutées au moment du paiment.
    </p>
    <p>
        <b>Chemin vers le fichier .vpp = ./diagrammes/vpp_files/Design/Sequences/Scenario_2.vpp</b>
        <svg width="1000px" height="400px" style="max-width: 100%; height: auto; display: block; margin-top: 10px;">
            <image href="./diagrammes/Sequence_ReserveASeat.png" width="100%" height="100%"  />
        </svg>
    </p>

    <h4>Payer pour un siège</h4>
    <p>
        On a d'abord besoin de voir la validité de la réservation (si 24h sont passées). On a choisi de ne pas faire de verfication d'information personelle du client via une méthode, car
        on suppose que le système de l'aéroport ou de la compagnie aérienne le fait déjà. C'est le système bancaire qui fera la vérification des informations de paiement, pas le système ou la classe
        Paiement, car ce n'est pas notre responsabilité et nous n'avons pas les informations nécessaires pour le faire (comme les informations confidentielles du client).
        Le client recevra des confirmations en guise de feedback.
    </p>
    <p>
        <b>Chemin vers le fichier .vpp = ./diagrammes/vpp_files/Design/Sequences/Scenario_3.vpp</b>
        <svg width="1000px" height="400px" style="max-width: 100%; height: auto; display: block; margin-top: 10px;">
            <image href="./diagrammes/SequenceDiag22.jpg" width="100%" height="100%"  />
        </svg>
    </p>
 -->

    <h3>Diagramme de paquets</h3>
    <p>
        Nous avons choisi de suivre quelque chose similaire à la structure MVC. Ainsi, le premier paquet "Core" représente le controlleur, le paquet "Interface" représente
        la vue et le paquet "Transport" représente le modèle. Dans "Interface", nous avons inclut la singulière classe "Interface" pour pouvoir éventuellement ajouter d'autres vues.
        Dans "Transports", nous avons inclus les classes qui représentent les entités du domaine, soit les compagnies, les parcours, les moyens de transport et les places (sièges et cabines).
        Notre logique pour inclure certaines classes dans certains paquets était selon leur degré de communication dans le diagramme de classes et notre conception de l'eventuel programme.
        Dans "Core", nous avons inclus les classes qui représentent les actions que le système peut effectuer, soit les réservations et les paiements, ainsi qu'une communication avec
        l'interface via la classe "System" et l'entité de "Passager", qui existe seulement dans le contexte d'une réservation.
    </p>
    <p>
        <b>Chemin vers le fichier .vpp ./diagrammes/vpp_files/Design/Package/PackageDiagram3911.vpp</b>
        <svg width="1000px" height="400px" style="max-width: 100%; height: auto; display: block; margin-top: 10px;">
            <image href="./diagrammes/Diag_Pack.jpg" width="100%" height="100%"  />
        </svg>
    </p>



    <h2>Partie 3 - Contraintes OCL </h2>

    <div>
        <p>
            Nous avons vérifié toutes les contraintes OCL qui n'avaient pas d'erreur après la correction du devoir 1, et elles étaient toujours valides pour le nouveau diagramme de classes. Donc, ci-dessous, nous corrigeons uniquement celles qui étaient erronées.
        </p>
        <p>
            <ol>
                <li>
                    <i>Un vol est identifié par un ID qui commence par deux lettres suivi d'une série de chiffres. La partie alphabétique de l'ID d'un vol est unique à chaque compagnie et la partie numérique est unique à chaque vol au sein de la même compagnie.</i>
                    <br><br>
                    context Cie_aerienne <br>
                    &nbsp;&nbsp;&nbsp;&nbsp; inv : self.short_ID.size() = 2 <br>
                    &nbsp;&nbsp;&nbsp;&nbsp; inv : self.allInstances() &rarr; isUnique(short_ID) <br>
                    &nbsp;&nbsp;&nbsp;&nbsp; inv : self.volsOfferts &rarr; forAll(v1, v2 | v1 <> v2 implies v1.substring(2, v1.size()) <> v2.substring(2, v2.size())) <br>
                </li>
                <br>
                <li>
                    <i>Un paquebot peut être assigné à plusieurs itinéraires tant qu'ils ne se chevauchent pas.</i>
                    <br><br>
                    context Paquebot <br>
                    &nbsp;&nbsp;&nbsp;&nbsp; inv : self.total_parcours &rarr; forAll(p1, p2 | p1 <> p2 implies p1 &rarr; intersection(p2) &rarr; isEmpty()) <br>
                </li>
                <br>
                <li>
                    <i>Le client peut réserver un siège disponible dans un vol (trajet) donné. / Le client peut réserver une cabine disponible pour un itinéraire donné.</i>
                    <br><br>
                    context Systeme::creerReservation(Parcours pa, Section s, Preference pr) <br>
                    &nbsp;&nbsp;&nbsp;&nbsp; pre : s.DispoSect <br>
                </li>
                <br>
                <li>
                    <i>Un siège réservé devient assigné à un passager une fois payé: le siège est donc confirmé.</i>
                    <br><br>
                    context Reservation::setValid() <br>
                    &nbsp;&nbsp;&nbsp;&nbsp; post : not self.place.DispoPlace <br>
                </li>
                <br>
            </ol>
        </p>
    </div>

</body>
</html>
