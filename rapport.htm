<html>
<head>
    <title>IFT3911 DM1</title>
    <style type="text/css">
        table
        {
            border: outset 2px black;
            border-collapse: collapse;
        }
        th
        {
            border-bottom: double 2px black;
        }
        td
        {
            border-bottom: solid 1px black;
        }
        .first_col
        {
            border-right: double 2px black;
        }
    </style>
</head>
<body>
    <h1 style="text-align: center;">
        IFT 3911 - Devoir 2 - Mike</h1>
    <h2>
        Information générale</h2>
    <p>
        <span style="font-weight: bold;">Nom: </span>Amélie Coughlan
        <br />
        <span style="font-weight: bold;">Matricule: </span> 9813
        <br />
        <span style="font-weight: bold;">Courriel: </span>amelie.therese.coughlan@umontreal.ca
        <br />
        <span style="font-weight: bold;">temps mis: </span> 20h
    </p>
    <p>
        <span style="font-weight: bold;">Nom: </span>Cassandre Hamel
        <br />
        <span style="font-weight: bold;">Matricule: </span> 0863
        <br />
        <span style="font-weight: bold;">Courriel: </span>cassandre.hamel.1@umontreal.ca
        <br />
        <span style="font-weight: bold;">temps mis: </span> 20h
    </p>
    <p>
        <span style="font-weight: bold;">Nom: </span>Alessandra Mancas
        <br />
        <span style="font-weight: bold;">Matricule: </span>9098
        <br />
        <span style="font-weight: bold;">Courriel: </span>alessandra.thais.mancas@umontreal.ca
        <br />
        <span style="font-weight: bold;">temps mis: </span> 20h
    </p>
    <h2>
        Distribution des tâches</h2>
    <p>
        <span style="font-weight: bold;">Soumetteur: </span>Alessandra Mancas
    </p>
    <table cellpadding="7px">
        <thead>
            <tr>
                <th>
                    Amélie
                </th>
                <th>
                    Cassandre
                </th>
                <th>
                    Alessandra
                </th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>
                    Statechart, OCL, qualité du design, rapport
                </td>
                <td>
                    Réseau de Pétri, diagramme de paquets, diagramme de classes, qualité du design, rapport
                </td>
                <td>
                    Diagramme de classes, diagrammes de séquence, OCL, qualité du design, rapport
                </td>
            </tr>

        </tbody>
    </table>

    <h2>Tâche 1 - Réseau de Pétri: Tunnel</h2>

    <h3>Modélisation du réseau de Pétri</h3>
    <p>
        <img src="./Diagrammes/PetriNetTunnel.png" alt="Réseau de Pétri" style="max-width: 100%; height: auto; display: block; margin-top: 10px;">
    </p>

    <h3>Analyse du réseau de Pétri</h3>
    <h4>Places: </h4>
    <p>
        <ul>
            <li>P_m, P_rs: représente la présence d'une voiture en attente soit à l'entrée du tunnel (Montreal) ou à l'entrée du tunnel (Rive-Sud).</li>
            <li>G_m, G_rs: représente si le feu est vert à l'entrée du tunnel (Montreal) ou à l'entrée du tunnel (Rive-Sud).</li>
            <li>D_m, D_rs: représente vers où la voiture va, soit Montreal ou Rive-Sud.</li>
            <li>T_m->rs, T_rs->m: représente le tunnel, soit de Montreal à Rive-Sud ou de Rive-Sud à Montreal.</li>
        </ul>
        <p>
            P_m et P_rs ont toujours une voiture en attente ainsi elles ont toujours un jeton.
        </p>
    <h4>Transitions: </h4>
    <p>
       <ul>
        <li>t_m_en, t_rs_en: représente l'entrée d'une voiture à l'entrée du tunnel (Montreal) ou à l'entrée du tunnel (Rive-Sud).</li>
        <li>t_ex_m, t_ex_rs: représente la sortie d'une voiture à l'entrée du tunnel (Montreal) ou à l'entrée du tunnel (Rive-Sud).</li>
       </ul>
    </p>
    <h4>Les arcs: </h4>
    <!--Should be tables : Transition | Places in | Places out -->

    <table cellpadding="7px">
        <thead>
            <tr>
                <th>
                    Transition
                </th>
                <th>
                    Places entrantes
                </th>
                <th>
                    Places sortantes
                </th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>
                    t_m_en
                </td>
                <td>
                    P_m, G_m, D_rs
                </td>
                <td>
                    P_m, T_m->rs
                </td>
            </tr>
            <tr>
                <td>
                    t_rs_en
                </td>
                <td>
                    P_rs, G_rs, D_m
                </td>
                <td>
                    P_rs, T_rs->m
                </td>
            </tr>
            <tr>
                <td>
                    t_ex_m
                </td>
                <td>
                    T_rs->m
                </td>
                <td>
                    D_rs, G_m
                </td>
            </tr>
            <tr>
                <td>
                    t_ex_rs
                </td>
                <td>
                    T_m->rs
                </td>
                <td>
                    D_m, G_rs
                </td>
            </tr>
        </tbody>

    </table>

    <h4>Marquage initial: </h4>
    <p>
        <ul>
            <li>P_m = 1, P_rs = 1, G_m = 1, G_rs = 0, D_m = 0, D_rs = 1, T_m->rs = 0, T_rs->m = 0</li>
        </ul>
    </p>

    <h4>Loi de conservation: </h4>
    <p>
        Loi 1 - Seulement une voiture dans le tunnel : M(T_m->rs) + M(T_rs->m) + M(G_m) + M(G_rs)  = 1 <br>
            ce qui implique que les voitures ne peuvent pas se croiser : M(T_m->rs) + M(T_rs->m) = 1
            et que les voitures ne peuvent pas entrer dans le tunnel si le feu est rouge : M(G_m) = 0 et M(G_rs) = 0
        Loi 2 - Les voitures alternent entre les deux directions : M(D_m) + M(D_rs) = 1 <br>
            ceci force les voitures à sortir du tunnel dans la direction opposée à celle d'entrée
            et cause une alternance stricte entre les voitures entrant à Montreal et à Rive-Sud
        Loi 3 - Il y a toujours une voiture à chaque entrée : M(P_m) + M(P_rs) = 2 <br>
    </p>

    <h4>Graphe d'accessibilité: </h4>
    <p>
        <ul>
            Pour le noeud : (P_m, G_m, D_rs, T_m->rs, T_rs->m, P_rs, G_rs, D_m) <br>
            <li>1. (1,1,1,0,0,1,0,0) -> t_m_en -> (1,0,0,1,0,1,0,0)</li>
            <li>2. (1,0,0,1,0,1,0,0) -> t_ex_rs -> (1,0,0,0,0,1,1,1)</li>
            <li>3. (1,0,0,0,0,1,1,1) -> t_rs_en -> (1,0,0,0,1,1,0,0)</li>
            <li>4. (1,0,0,0,1,1,0,0) -> t_ex_m -> (1,1,1,0,0,1,0,0)</li>
            <li>5. Le marquage initial est atteint</li>
        </ul>
    </p>

    <h4>Propriétés: </h4>
    <p>Est-ce que le réseau est borné? Oui, car seulement une voiture peut être dans le tunnel à la fois, et il y a toujours une voiture à chaque entrée. </p>
    <p>Y-a-t-il une loi de conservation? Oui, les voitures ne peuvent pas se croiser et les voitures alternent entre les deux directions.</p>
    <p>Y-a-t-il une situation d'interblocage? Non, il y a un cycle qui accede à chaque transition, aucun neoud du graphe reste terminal.</p>
    <p>Y-a-t-il une situation de famine? Non, puisqu'il y a une alternance stricte entre les voitures entrant à Montreal et à Rive-Sud.</p>
    <p>Y-a-t-il des transitions mortes? Non, puisque chaque transition reste activable indefiniment du a l'alternance stricte qui visite chaque transition. (L4) </p>

    </p>



    <h2>Tâche 2 - Statechart: Four à micro-onde</h2>

    <h3>Modélisation du Statechart</h3>

    <p>
        <b>Chemin vers le répertoire du State Chart = ./Microwave</b>
        <p>
            <img src="./Diagrammes/StateChart.png" alt="Réseau de Pétri" style="max-width: 100%; height: auto; display: block; margin-top: 10px;">
        </p>
    </p>
    <h3>Précisions</h3>
        <p>
            <ul>
                <li>
                    <i>La porte peut être ouverte ou fermée en tout temps. Pour des raisons de sécurité, la cuisson ne peut avoir lieu si la porte est ouverte. Durant la cuisson, l'ouverture de la porte interrompt la cuisson. Le message 'Waiting' est alors affiché. Lorsque la porte est refermée, l'afficheur affiche le texte précédent l'ouverture (message ou temps).</i>
                    <br><br>
                    Il y a ici une ambiguïté dans les instructions quant à si on doit afficher le 'Waiting' seulement quand on ouvre la porte pendant la cuisson, ou si on doit l'afficher n'importe quand qu'on l'ouvre. Après plusieurs interactions avec plusieurs micro-ondes différents, nous avons conclu qu'il est possible de faire d'autres inputs dans le clavier du micro-ondes pendant qu'il est ouvert, sauf pour partir la cuisson. Dans ce cas, il ne ferait pas de sens d'afficher 'Waiting', étant donné qu'on doit continuer à afficher le résultat des inputs. Nous avons décidé d'implémenter ce comportement. Donc, ce message est seulement affiché quand on ouvre la porte pendant la cuisson. Aucun input ne peut être entré pendant ce temps, on peut seulement fermer la porte, ou appuyer sur stop pour recommencer le processus.
                </li>
                <br>
                <li>
                    <i>Appuyer sur stop arrête tout le processus et met le système au repos.</i>
                    <br><br>
                    Nous avons interprété le fait de mettre le système au repos de le recommencer. Donc, quand on appuie sur stop à n'importe quel moment, que ce soit pendant la cuisson ou pendant de l'input dans le clavier, on interromp tout et on peut recommencer. 
                </li>
                <br>
                <li>
                    Pour une raison quelconque, les triggers 'always' et 'oncycle' ne marchaient pas tout à fait de la manière attendue. La documentation de Yakindu indique clairement que les transitions avec un de ces triggers se déclenchera immédiatement lorsque les fonctions entry/ et exit/ ont terminé dans l'état de départ. Toutefois, il fallait toujours peser sur n'importe quel bouton sur le clavier pour permettre la transition. C'est pourquoi il y a 2 transitions qui ont comme trigger <b>after 2ms</b>, c'était la meilleure façon de simuler des transitions immédiates (utiliser 0s générait d'autres bogues).
                </li>
            </ul>
        </p>

    <h2>Tâche 3 - Design logiciel</h2>
    <h3>Révision du diagramme de classe</h3>
        <p>
            <!--METTRE IMAGE ET FILE PATH-->

        </p>
    <h3>Révision des diagrammes de séquence</h3>
        <p></p>
    <h3>Révision du diagramme de paquets</h3>
        <p></p>
    <h3>Révision des contraintes OCL</h3>
    <div>
        <p>
            Nous avons vérifié toutes les contraintes OCL qui n'avaient pas d'erreur après la correction du devoir 1, et elles étaient toujours valides pour le nouveau diagramme de classes. Donc, ci-dessous, nous corrigeons uniquement celles qui étaient erronées.
        </p>
        <p>
            <ol>
                <li>
                    <i>Un vol est identifié par un ID qui commence par deux lettres suivi d'une série de chiffres. La partie alphabétique de l'ID d'un vol est unique à chaque compagnie et la partie numérique est unique à chaque vol au sein de la même compagnie.</i>
                    <br><br>
                    context Cie_aerienne <br>
                    &nbsp;&nbsp;&nbsp;&nbsp; inv : self.short_ID.size() = 2 <br>
                    &nbsp;&nbsp;&nbsp;&nbsp; inv : self.allInstances() &rarr; isUnique(short_ID) <br>
                    &nbsp;&nbsp;&nbsp;&nbsp; inv : self.volsOfferts &rarr; forAll(v1, v2 | v1 <> v2 implies v1.substring(2, v1.size()) <> v2.substring(2, v2.size())) <br>
                </li>
                <br>
                <li>
                    <i>Un paquebot peut être assigné à plusieurs itinéraires tant qu'ils ne se chevauchent pas.</i>
                    <br><br>
                    context Paquebot <br>
                    &nbsp;&nbsp;&nbsp;&nbsp; inv : self.total_parcours &rarr; forAll(p1, p2 | p1 <> p2 implies p1 &rarr; intersection(p2) &rarr; isEmpty()) <br>
                </li>
                <br>
                <li>
                    <i>Le client peut réserver un siège disponible dans un vol (trajet) donné. / Le client peut réserver une cabine disponible pour un itinéraire donné.</i>
                    <br><br>
                    context Systeme::creerReservation(Parcours pa, Section s, Preference pr) <br>
                    &nbsp;&nbsp;&nbsp;&nbsp; pre : s.DispoSect <br>
                </li>
                <br>
                <li>
                    <i>Un siège réservé devient assigné à un passager une fois payé: le siège est donc confirmé.</i>
                    <br><br>
                    context Reservation::setValid() <br>
                    &nbsp;&nbsp;&nbsp;&nbsp; post : not self.place.DispoPlace <br>
                </li>
                <br>
            </ol>
        </p>
    </div>
    <h3>Identification des modules réutilisables</h3>
        <p></p>

    <h2>Tâche 4 - Qualité du design</h2>
        <p></p>
    <h3>Discussion du couplage et de la cohésion des modules</h3>
        <p></p>
    <h3>Discussion du fardeau des classes</h3>
        <p></p>
    <h3>Graphe IA et justification</h3>
        <svg width="1000px" height="400px" style="max-width: 100%; height: auto; display: block; margin-top: 10px;">
            <image href="./diagrammes/IA_graph.png" width="100%" height="100%"  />
        </svg>
        <p></p>
    <h3>Justification de l'application des principes de conception</h3>
        <p></p>

    <!--<h3>Diagramme de paquets</h3>
    <p>
        Nous avons choisi de suivre quelque chose similaire à la structure MVC. Ainsi, le premier paquet "Core" représente le controlleur, le paquet "Interface" représente
        la vue et le paquet "Transport" représente le modèle. Dans "Interface", nous avons inclut la singulière classe "Interface" pour pouvoir éventuellement ajouter d'autres vues.
        Dans "Transports", nous avons inclus les classes qui représentent les entités du domaine, soit les compagnies, les parcours, les moyens de transport et les places (sièges et cabines).
        Notre logique pour inclure certaines classes dans certains paquets était selon leur degré de communication dans le diagramme de classes et notre conception de l'eventuel programme.
        Dans "Core", nous avons inclus les classes qui représentent les actions que le système peut effectuer, soit les réservations et les paiements, ainsi qu'une communication avec
        l'interface via la classe "System" et l'entité de "Passager", qui existe seulement dans le contexte d'une réservation.
    </p>
    <p>
        <b>Chemin vers le fichier .vpp ./diagrammes/vpp_files/Design/Package/PackageDiagram3911.vpp</b>
        <svg width="1000px" height="400px" style="max-width: 100%; height: auto; display: block; margin-top: 10px;">
            <image href="./diagrammes/Diag_Pack.jpg" width="100%" height="100%"  />
        </svg>
    </p>-->

</body>
</html>
